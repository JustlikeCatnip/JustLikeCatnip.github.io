[{"title":"MetaFac——数字工厂案例展示","url":"/2024/02/27/MetaFac数字工厂/","content":"\n## **项目架构**\n\n**1.前端（基于vue.js开发）**\n\n**2.后端 （基于springboot、tomcat开发）**\n\n**3.数据库（基于MySQL数据库）**\n\n**4.可视化模块（基于three.js开发）**\n\n**5.框架使用（JeecgBoot、FineReport）**\n\n展示效果示例:\n\n**前端架构图**\n\n![](MetaFac数字工厂/前端架构.png)\n\n**后端架构图**\n\n![](MetaFac数字工厂/后端架构.png)\n\n**案例模型核心模块**\n\n样例模型：\n\n![](MetaFac数字工厂/样例模型.png)\n\n实际模拟搭建效果：\n\n![](MetaFac数字工厂/大屏搭建效果.png)\n\n!(MetaFac数字工厂/案例模型模块_2.png)\n\n![](MetaFac数字工厂/案例模型模块_2.png)\n\n**可视化数字大屏**\n\n![](MetaFac数字工厂/数字化大屏.gif)\n\nAGV设备运输模拟：\n\n![](MetaFac数字工厂/AGV运输模拟.gif)\n","tags":["Three.js"],"categories":["前端"]},{"title":"element-admin源码解读(Store)","url":"/2024/02/25/element-admin源码解读/","content":"\n## Store模块源码分析\n\n------\n\n#### 目录：\n\n![](element-admin源码解读(Store)/menu.png)\n\n​\t首先让我们来看一下目录，在本系统中**Store**主要用于存储一些<u>全局的共享参数</u>，包括**应用参数（app.js）、错误日志（errorLog.js）、鉴权信息（permission.js）、系统设置（setting.js）、面包屑导航（tagsView.js）、用户信息（user.js）**\n\n------\n\n### 数据的存储：\n\n#### app.js\n\n```javascript\nimport Cookies from 'js-cookie'\n\nconst state = {\n  sidebar: {\n    opened: Cookies.get('sidebarStatus') ? !!+Cookies.get('sidebarStatus') : true,\n    withoutAnimation: false\n  },\n  device: 'desktop',\n  size: Cookies.get('size') || 'medium'\n}\n\nconst mutations = {\n  TOGGLE_SIDEBAR: state => {\n    state.sidebar.opened = !state.sidebar.opened\n    state.sidebar.withoutAnimation = false\n    if (state.sidebar.opened) {\n      Cookies.set('sidebarStatus', 1)\n    } else {\n      Cookies.set('sidebarStatus', 0)\n    }\n  },\n  CLOSE_SIDEBAR: (state, withoutAnimation) => {\n    Cookies.set('sidebarStatus', 0)\n    state.sidebar.opened = false\n    state.sidebar.withoutAnimation = withoutAnimation\n  },\n  TOGGLE_DEVICE: (state, device) => {\n    state.device = device\n  },\n  SET_SIZE: (state, size) => {\n    state.size = size\n    Cookies.set('size', size)\n  }\n}\n\nconst actions = {\n  toggleSideBar({ commit }) {\n    commit('TOGGLE_SIDEBAR')\n  },\n  closeSideBar({ commit }, { withoutAnimation }) {\n    commit('CLOSE_SIDEBAR', withoutAnimation)\n  },\n  toggleDevice({ commit }, device) {\n    commit('TOGGLE_DEVICE', device)\n  },\n  setSize({ commit }, size) {\n    commit('SET_SIZE', size)\n  }\n}\n\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions\n}\n\n```\n\n- 首先在头部引入网页Cookies工具类，用于后续进行cookies操作\n- state中配置三个参数\n  - *sidebar*（侧边栏）\n    - opened（控制开关状态)：主要使用**Cookies**来记录侧边栏的开关状态\n    - **!!**   能够强制转换后续表达式返回值为boolean避免数据类型不一致的问题,例如undefined->false,null->false\n    - **+**   则进行字符串的自动转换\n    - withoutAnimation（控制收缩动画）\n  - device（设备类型）\n  - size（界面字体尺寸）\n\n#### errorLog.js\n\n```javascript\nconst state = {\n  logs: []\n}\n\nconst mutations = {\n  ADD_ERROR_LOG: (state, log) => {\n    state.logs.push(log)\n  },\n  CLEAR_ERROR_LOG: (state) => {\n    state.logs.splice(0)\n  }\n}\n\nconst actions = {\n  addErrorLog({ commit }, log) {\n    commit('ADD_ERROR_LOG', log)\n  },\n  clearErrorLog({ commit }) {\n    commit('CLEAR_ERROR_LOG')\n  }\n}\n\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions\n}\n```\n\n<u>logs数组用于存储每次产生的错误日志</u>\n\n#### permission.js\n\n```javascript\nimport { asyncRoutes, constantRoutes } from '@/router'\n\n/**\n * Use meta.role to determine if the current user has permission\n * @param roles\n * @param route\n */\nfunction hasPermission(roles, route) {\n  if (route.meta && route.meta.roles) {\n    return roles.some(role => route.meta.roles.includes(role))\n  } else {\n    return true\n  }\n}\n\n/**\n * Filter asynchronous routing tables by recursion\n * @param routes asyncRoutes\n * @param roles\n */\nexport function filterAsyncRoutes(routes, roles) {\n  const res = []\n\n  routes.forEach(route => {\n    const tmp = { ...route }\n    if (hasPermission(roles, tmp)) {\n      if (tmp.children) {\n        tmp.children = filterAsyncRoutes(tmp.children, roles)\n      }\n      res.push(tmp)\n    }\n  })\n\n  return res\n}\n\nconst state = {\n  routes: [],\n  addRoutes: []\n}\n\nconst mutations = {\n  SET_ROUTES: (state, routes) => {\n    state.addRoutes = routes\n    state.routes = constantRoutes.concat(routes)\n  }\n}\n\nconst actions = {\n  generateRoutes({ commit }, roles) {\n    return new Promise(resolve => {\n      let accessedRoutes\n      if (roles.includes('admin')) {\n        accessedRoutes = asyncRoutes || []\n      } else {\n        accessedRoutes = filterAsyncRoutes(asyncRoutes, roles)\n      }\n      commit('SET_ROUTES', accessedRoutes)\n      resolve(accessedRoutes)\n    })\n  }\n}\n\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions\n}\n```\n\n- 首先引入静态路由和动态路由\n\n  - **AcyncRouters：所有路由**\n  - **ConstantRouters：静态路由**\n- **hasPermisson（）**： 传入**角色**和**某个路由**，判断该角色是否**有使用该路由的权限**\n- **filterAsyncRoutes（）**：传入**角色**和**所有路由**，过滤掉所有无权的路由，返回**该用户的路由数组**\n- **generateRoutes（）**：回调函数，传入**角色**，执行过滤方法和设置路由方法，将最终路由持久化保存在state的routes数组中，该权限下的额外路由添加在state的addRoutes数组中\n\n#### setting.js\n\n```javascript\nimport variables from '@/styles/element-variables.scss'\nimport defaultSettings from '@/settings'\n\nconst { showSettings, tagsView, fixedHeader, sidebarLogo } = defaultSettings\n\nconst state = {\n  theme: variables.theme,\n  showSettings: showSettings,\n  tagsView: tagsView,\n  fixedHeader: fixedHeader,\n  sidebarLogo: sidebarLogo\n}\n\nconst mutations = {\n  CHANGE_SETTING: (state, { key, value }) => {\n    // eslint-disable-next-line no-prototype-builtins\n    if (state.hasOwnProperty(key)) {\n      state[key] = value\n    }\n  }\n}\n\nconst actions = {\n  changeSetting({ commit }, data) {\n    commit('CHANGE_SETTING', data)\n  }\n}\n\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions\n}\n\n```\n\n- 首先引入全局css样式和默认配置文件\n- 设置state参数**theme|showSettings|tagsView|tagsView|fixedHeader|sidebarLogo**\n\n#### tagsView.js\n\n```javascript\nconst state = {\n  visitedViews: [],\n  cachedViews: []\n}\n\nconst mutations = {\n  ADD_VISITED_VIEW: (state, view) => {\n    if (state.visitedViews.some(v => v.path === view.path)) return\n    state.visitedViews.push(\n      Object.assign({}, view, {\n        title: view.meta.title || 'no-name'\n      })\n    )\n  },\n  ADD_CACHED_VIEW: (state, view) => {\n    if (state.cachedViews.includes(view.name)) return\n    if (!view.meta.noCache) {\n      state.cachedViews.push(view.name)\n    }\n  },\n\n  DEL_VISITED_VIEW: (state, view) => {\n    for (const [i, v] of state.visitedViews.entries()) {\n      if (v.path === view.path) {\n        state.visitedViews.splice(i, 1)\n        break\n      }\n    }\n  },\n  DEL_CACHED_VIEW: (state, view) => {\n    const index = state.cachedViews.indexOf(view.name)\n    index > -1 && state.cachedViews.splice(index, 1)\n  },\n\n  DEL_OTHERS_VISITED_VIEWS: (state, view) => {\n    state.visitedViews = state.visitedViews.filter(v => {\n      return v.meta.affix || v.path === view.path\n    })\n  },\n  DEL_OTHERS_CACHED_VIEWS: (state, view) => {\n    const index = state.cachedViews.indexOf(view.name)\n    if (index > -1) {\n      state.cachedViews = state.cachedViews.slice(index, index + 1)\n    } else {\n      // if index = -1, there is no cached tags\n      state.cachedViews = []\n    }\n  },\n\n  DEL_ALL_VISITED_VIEWS: state => {\n    // keep affix tags\n    const affixTags = state.visitedViews.filter(tag => tag.meta.affix)\n    state.visitedViews = affixTags\n  },\n  DEL_ALL_CACHED_VIEWS: state => {\n    state.cachedViews = []\n  },\n\n  UPDATE_VISITED_VIEW: (state, view) => {\n    for (let v of state.visitedViews) {\n      if (v.path === view.path) {\n        v = Object.assign(v, view)\n        break\n      }\n    }\n  }\n}\n\nconst actions = {\n  addView({ dispatch }, view) {\n    dispatch('addVisitedView', view)\n    dispatch('addCachedView', view)\n  },\n  addVisitedView({ commit }, view) {\n    commit('ADD_VISITED_VIEW', view)\n  },\n  addCachedView({ commit }, view) {\n    commit('ADD_CACHED_VIEW', view)\n  },\n\n  delView({ dispatch, state }, view) {\n    return new Promise(resolve => {\n      dispatch('delVisitedView', view)\n      dispatch('delCachedView', view)\n      resolve({\n        visitedViews: [...state.visitedViews],\n        cachedViews: [...state.cachedViews]\n      })\n    })\n  },\n  delVisitedView({ commit, state }, view) {\n    return new Promise(resolve => {\n      commit('DEL_VISITED_VIEW', view)\n      resolve([...state.visitedViews])\n    })\n  },\n  delCachedView({ commit, state }, view) {\n    return new Promise(resolve => {\n      commit('DEL_CACHED_VIEW', view)\n      resolve([...state.cachedViews])\n    })\n  },\n\n  delOthersViews({ dispatch, state }, view) {\n    return new Promise(resolve => {\n      dispatch('delOthersVisitedViews', view)\n      dispatch('delOthersCachedViews', view)\n      resolve({\n        visitedViews: [...state.visitedViews],\n        cachedViews: [...state.cachedViews]\n      })\n    })\n  },\n  delOthersVisitedViews({ commit, state }, view) {\n    return new Promise(resolve => {\n      commit('DEL_OTHERS_VISITED_VIEWS', view)\n      resolve([...state.visitedViews])\n    })\n  },\n  delOthersCachedViews({ commit, state }, view) {\n    return new Promise(resolve => {\n      commit('DEL_OTHERS_CACHED_VIEWS', view)\n      resolve([...state.cachedViews])\n    })\n  },\n\n  delAllViews({ dispatch, state }, view) {\n    return new Promise(resolve => {\n      dispatch('delAllVisitedViews', view)\n      dispatch('delAllCachedViews', view)\n      resolve({\n        visitedViews: [...state.visitedViews],\n        cachedViews: [...state.cachedViews]\n      })\n    })\n  },\n  delAllVisitedViews({ commit, state }) {\n    return new Promise(resolve => {\n      commit('DEL_ALL_VISITED_VIEWS')\n      resolve([...state.visitedViews])\n    })\n  },\n  delAllCachedViews({ commit, state }) {\n    return new Promise(resolve => {\n      commit('DEL_ALL_CACHED_VIEWS')\n      resolve([...state.cachedViews])\n    })\n  },\n\n  updateVisitedView({ commit }, view) {\n    commit('UPDATE_VISITED_VIEW', view)\n  }\n}\n\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions\n}\n```\n\n- **visitedViews**用于存储前几个父标签，**cachedViews**用于存储正在访问的当前标签\n- **visitedViews**通过遍历的方式生成，主要方式是传入路由时，判断path是否一致，如果不一致则更新\n- **cachedViews**通过indexOf函数查询并修改\n\n#### user.js\n\n```javascript\nimport { login, logout, getInfo } from '@/api/user'\nimport { getToken, setToken, removeToken } from '@/utils/auth'\nimport router, { resetRouter } from '@/router'\n\nconst state = {\n  token: getToken(),\n  name: '',\n  avatar: '',\n  introduction: '',\n  roles: []\n}\n\nconst mutations = {\n  SET_TOKEN: (state, token) => {\n    state.token = token\n  },\n  SET_INTRODUCTION: (state, introduction) => {\n    state.introduction = introduction\n  },\n  SET_NAME: (state, name) => {\n    state.name = name\n  },\n  SET_AVATAR: (state, avatar) => {\n    state.avatar = avatar\n  },\n  SET_ROLES: (state, roles) => {\n    state.roles = roles\n  }\n}\n\nconst actions = {\n  // user login\n  login({ commit }, userInfo) {\n    const { username, password } = userInfo\n    return new Promise((resolve, reject) => {\n      login({ username: username.trim(), password: password }).then(response => {\n        const { data } = response\n        commit('SET_TOKEN', data.token)\n        setToken(data.token)\n        resolve()\n      }).catch(error => {\n        reject(error)\n      })\n    })\n  },\n\n  // get user info\n  getInfo({ commit, state }) {\n    return new Promise((resolve, reject) => {\n      getInfo(state.token).then(response => {\n        const { data } = response\n\n        if (!data) {\n          reject('Verification failed, please Login again.')\n        }\n\n        const { roles, name, avatar, introduction } = data\n\n        // roles must be a non-empty array\n        if (!roles || roles.length <= 0) {\n          reject('getInfo: roles must be a non-null array!')\n        }\n\n        commit('SET_ROLES', roles)\n        commit('SET_NAME', name)\n        commit('SET_AVATAR', avatar)\n        commit('SET_INTRODUCTION', introduction)\n        resolve(data)\n      }).catch(error => {\n        reject(error)\n      })\n    })\n  },\n\n  // user logout\n  logout({ commit, state, dispatch }) {\n    return new Promise((resolve, reject) => {\n      logout(state.token).then(() => {\n        commit('SET_TOKEN', '')\n        commit('SET_ROLES', [])\n        removeToken()\n        resetRouter()\n\n        // reset visited views and cached views\n        // to fixed https://github.com/PanJiaChen/vue-element-admin/issues/2485\n        dispatch('tagsView/delAllViews', null, { root: true })\n\n        resolve()\n      }).catch(error => {\n        reject(error)\n      })\n    })\n  },\n\n  // remove token\n  resetToken({ commit }) {\n    return new Promise(resolve => {\n      commit('SET_TOKEN', '')\n      commit('SET_ROLES', [])\n      removeToken()\n      resolve()\n    })\n  },\n\n  // dynamically modify permissions\n  async changeRoles({ commit, dispatch }, role) {\n    const token = role + '-token'\n\n    commit('SET_TOKEN', token)\n    setToken(token)\n\n    const { roles } = await dispatch('getInfo')\n\n    resetRouter()\n\n    // generate accessible routes map based on roles\n    const accessRoutes = await dispatch('permission/generateRoutes', roles, { root: true })\n    // dynamically add accessible routes\n    router.addRoutes(accessRoutes)\n\n    // reset visited views and cached views\n    dispatch('tagsView/delAllViews', null, { root: true })\n  }\n}\n\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions\n}\n\n```\n\n- 首先引入几个模块：**user的API接口请求函数**、**token的配置函数**、**路由的配置函数**\n- 主要存储state参数为：**用户信息相关参数（name、avatar、introduction）**、**鉴权token**、**角色roles数组**\n- 主要功能需要更新用户信息并持久化存储至全局，调用方法**配置用户信息**，生成**token**，调用获取**用户信息的API**以取得用户**角色**，并调用**路由的配置函数（先前配置的）**来生成动态路由。\n\n------\n\n### 数据的获取：\n\n#### 代码演示：\n\n```javascript\nconst getters = {\n  sidebar: state => state.app.sidebar,\n  size: state => state.app.size,\n  device: state => state.app.device,\n  visitedViews: state => state.tagsView.visitedViews,\n  cachedViews: state => state.tagsView.cachedViews,\n  token: state => state.user.token,\n  avatar: state => state.user.avatar,\n  name: state => state.user.name,\n  introduction: state => state.user.introduction,\n  roles: state => state.user.roles,\n  permission_routes: state => state.permission.routes,\n  errorLogs: state => state.errorLog.logs\n}\nexport default getters\n```\n\n由于获取数据的方式都大同小异。因此，设置通用getter类来获取全部state参数。\n\n------\n\n### Store的生成：\n\n将store初始化配置在Vuex，进行模块化管理，以下是代码展示\n\n```javascript\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport getters from './getters'\n\nVue.use(Vuex)\n\n// https://webpack.js.org/guides/dependency-management/#requirecontext\nconst modulesFiles = require.context('./modules', true, /\\.js$/)\n\n// you do not need `import app from './modules/app'`\n// it will auto require all vuex module from modules file\nconst modules = modulesFiles.keys().reduce((modules, modulePath) => {\n  // set './app.js' => 'app'\n  const moduleName = modulePath.replace(/^\\.\\/(.*)\\.\\w+$/, '$1')\n  const value = modulesFiles(modulePath)\n  modules[moduleName] = value.default\n  return modules\n}, {})\n\nconst store = new Vuex.Store({\n  modules,\n  getters\n})\n\nexport default store\n```\n\n------\n\n### 全局调用Store：\n\n​\t最后直接在js中调用更新store即可,以**用户登录**为例：\n\n```javascript\nthis.$store.dispatch('user/login', this.loginForm);\n```\n\n","tags":["源码分析"],"categories":["前端"]},{"title":"Express中间件与Router","url":"/2024/02/24/Express中间件与Router/","content":"\n### Router模块\n\n------\n\n- 模块化搭建（与Vue类似）\n- 先引入router模块，挂载到具体路由，在通过export抛出\n- 最后在app上注册全局注册\n\n*router*\n\n```js\n//这是路由模块\nconst express = require('express');\n//创建路由对象\nconst router = express.Router();\n\n\n//挂载具体的路由\nrouter.get('/user/list', (req, res) => {\n    res.send('Get user list!')\n})\n\nrouter.post('/user/add', (req, res) => {\n    res.send('Add new user!')\n})\n\n//抛出路由对象\nmodule.exports = router\n```\n\n*app*\n\n```js\nconst express = require('express');\nconst app = express();\n\nconst userRouter = require('./router');\n\n//注册全局中间件模块（例如路由）\napp.use('/api', userRouter)\n\napp.listen(1000, () => {\n    console.log(\"http://127.0.0.1:1000\");\n})\n```\n\n*测试*\n\n![](Express中间件与Router/router.png)\n\n------\n\n### Express中间件\n\n- 中间件相当与全局（或局部）定义的拦截器,作用于客户端发起请求\n  - 这里我们首先定义一个最简单的中间件，并将其注册到app上\n  - 最后测试\n\n```js\n const express = require(\"express\")\n const app = express();\n\n //定义一个最简单的中间件\n\n app.use(function(req, res, next) {\n     console.log(\"中间件已启动\");\n     const time = Date.now();\n     req.startTime = time;\n     //把流传关系，转交给下一个中间件或路由\n     next();\n });\n\n\n app.listen(8080, () => {\n     console.log(\"server running in http://127.0.0.1:8080\");\n })\n\n\n\n\n app.get('/', (req, res) => {\n     console.log('调用了/路由' + '时间是' + req.startTime);\n     res.send('Home Page');\n })\n\n app.get('/user', (req, res) => {\n     console.log('调用了/user路由' + '时间是' + req.startTime);\n     res.send('User Page');\n })\n```\n\n*注意：可以使用 app.use0 连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行*\n\n------\n\n### 局部中间件\n\n- 不使用app.use全局注册的中间件,即为局部中间件\n- 可以使用连续多个局部中间件,注意尾部加next()\n\n```js\nconst express = require(\"express\")\nconst app = express();\n\nconst mw1 = (req, res, next) => {\n    console.log(\"这是第一个中间件\");\n    next();\n}\nconst mw2 = (req, res, next) => {\n    console.log(\"这是第二个中间件\");\n    next();\n}\n\n\napp.get('/user', mw1, mw2, (req, res) => {\n    res.send(\"User Page\");\n})\n\n\napp.listen(8080, () => {\n    console.log(\"server running in http://127.0.0.1:8080\");\n})\n```\n\n## 中间件使用注意事项:\n\n1. 一定要在路由之前注册中间件\n2. 客户端发送过来的请求，可以连续调用多个中间件进行处理\n3. 执行完中间件的业务代码之后，不要忘记调用 next0 函数\n4. 为了防止代码逻辑混乱，调用 next0 函数后不要再写额外的代码\n5. 连续调用多个中间件时，多个中间件之间，共享req和res 对象\n\n**其它特殊中间件:**\n\n- 路由中间件(绑定到 express.Router0 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别)\n- 错误中间件(形参四个参数(err,req,res,next))\n\n```js\napp.get('/user', mw1, mw2, (req, res) => {\n    res.send(\"User Page\");\n})\n\n//注意 错误中间件一般放置所有路由之后，用于捕获整个项目的错误异常\napp.use((err, req, res, next) => {\n    console.log(\"error happend!\" + err.message);\n    res.send('error:' + err.message);\n\n})\n```\n\n- express内置中间件\n  - express.static 快速托管静态资源的内置中间件，例如: HTML 文件、图片、CSS 样式等(无兼容性)\n  - express.json 解析 JSON 格式的请求体数据(有兼容性，仅在 4.16.0+ 版本中可用)\n  - express.urlencoded 解析 URL-encoded 格式的请求体数据(有兼容性，仅在 4.16.0+ 版本中可用)\n- 第三方中间件\n  - npm install XXX\n  - require \n  - app.use()\n\n------\n\n### qs模块(现在弃用,改为URLSearchParams)\n\n- Node.js 内置了一个 querystring 模块，专门用来处理查询字符串。通过这个模块提供的 parse0) 函数，可以轻松把查询字符串，解析成对象的格式。\n\n```js\nconst qs = require('URLSearchParams');\nconsole.log('body='+qs.parse(result));\n```\n\n*注意:为了优化项目结构,我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下:*\n\n```js\nconst qs = require(\"URLSearchParams\");\n\nfunction bodyParser(req, res, next) {\n    /* 省略其它代码 */\n}\nmodule.exports = bodyParser;\n/*分割线*/\n其它js中直接通过require调用\n```\n\n","tags":["Node.js"],"categories":["后端"]},{"title":"docker入门及配置","url":"/2024/02/04/docker入门及配置/","content":"\n####  什么是docker？\n\n![](docker入门及配置/docker.png)\n\nDocker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的 Linux 机器上，也可以实现虚拟化。Docker 容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。\n\n------\n\n##### 安装：\n\n- yum包更新到最新\n\n  ```shell\n  yum update\n  ```\n\n- 安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\n\n  ```shell\n  yum install -y yum-utils device-mapper-persistent-data lvm2\n  ```\n\n- 设置yum源\n\n  ```shell\n  yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n  ```\n\n- 安装docker,出现输入的界面都按y\n\n  ```shell\n  yum install -y docker-ce\n  ```\n\n- 查看docker版本，验证是否成功\n\n  ```shell\n  docker -v\n  ```\n\n  **备注**：\n\n  <u>执行 yum install -y docker-ce 报错：</u>\n  <u>failure: repodata/repomd.xml from docker-ce-stable: 【Errno 256】 No more mirrors to try.</u>\n  <u>解决办法：</u>\n  <u>执行 vim /etc/yum.repos.d/docker-ce.repo，把第一个baseurl中的$releasever改成7，然后保存退出重新安装即可</u>\n\n------\n\n#### 镜像加速器配置:\n\n若docker镜像仓库下载较慢，可使用一些国内的镜像加速器，如阿里云、腾讯云等。\n\n![](docker入门及配置/docker镜像加速器.png)\n\n#### \n\n#### 基础命令：\n\n- docker 启动/关闭/重启 服务\n\n  ```shell\n  systemctl start/stop/restart docker\n  ```\n\n- 查看docker进程状态\n\n  ```shell\n  systemctl status docker\n  ```\n\n- 开机启动docker进程\n\n  ```shell\n  systemctl enable docker\n  ```\n\n------\n\n#### 镜像操作:\n\n- 查看镜像（所有）\n\n  ```shell\n  docker images\n  docker images -q # 查看所用镜像的id\n  ```\n\n- 搜索镜像（从docker hub仓库中查找）\n\n  ```shell\n  docker search XXX #镜像名称\n  ```\n\n- 拉取镜像（从docker仓库中下载镜像到本地）\n\n  ```shell\n  docker pull XXX #镜像名称\n  ```\n\n- 删除镜像（删除本地）\n\n  ```\n  docker rmi xxxxx #删除指定id的镜像\n  docker rmi 'docker images -q' #删除所有本地镜像\n  ```\n\n------\n\n#### 容器操作:\n\n- 创建并启动容器\n\n  ```shell\n  docker run 参数\n  -i #保持容器运行，通常与-t同时使用，加入-i-t这两个参数后，容器创建后会自动进入，退出容器后，容器自动关闭\n  -t #为容器重新分配一个为输入终端，通常与-i同时使用\n  -d #以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec进入容器。退出后，容器不会关闭。\n  -it #创建的容器一般称为交互式容器。\n  -id #创建的容器一般称为守护式容器。\n  --name #为创建的容器命名\n  ```\n\n- 查看容器\n\n  ```shell\n  docker ps #查看正在运行的容器\n  docker ps -a #查看所有容器\n  ```\n\n- 进入容器\n\n  ```shell\n  docker exec xxx #退出容器，容器不会关闭\n  ```\n\n- 停止容器\n\n  ```shell\n  docker stop xxx \n  ```\n\n- 启动容器\n\n  ```shell\n  docker start xxx \n  ```\n\n- 删除容器：如果容器是运行状态则删除失败，需要停止容器才能进行删除\n\n  ```shell\n  docker rm xxx \n  ```\n\n- 查看容器信息\n\n  ```shell\n  docker inspect xxx \n  ```\n\n------\n\n#### Docker数据卷：\n\n![](docker入门及配置/docker数据卷.png)\n\n##### 配置数据卷：\n\n```shell\ndocker run ... -v 宿主机目录:容器内目录 ...\n```\n\n注意事项：\n\n1. 目录必须是绝对路径\n2. 如果目录不存在，会自动创建\n3. 可以挂载多个数据卷\n4. 多个容器可以指定一个数据卷，以此实现容器间数据的双向绑定\n\n##### 容器数据卷：\n\n![](docker入门及配置/docker容器数据卷.png)\n\n------\n\n#### 应用部署：\n\n##### mysql5.7部署：\n\n1. 搜索镜像\n\n   ```shell\n   docker search mysql:5.7\n   ```\n\n2. 拉取镜像\n\n   ```shell\n   docker pull mysql:5.7\n   ```\n\n3. 创建容器，设置端口映射、目录映射\n\n   ```shell\n   # 在/root目录下创建mysql目录用于存储mysql数据信息\n   mkdir ~/mysql\n   cd ~/mysql\n   \n   docker run -id \\\n   -p 3307:3306 \\\n   --name=c_mysql \\\n   -v $pwd/conf:/etc/mysql/conf.d \\\n   -v $pwd/logs:/logs \\\n   -v $pwd/data:/var/var/lib/mysql \\\n   -e MYSQL_ROOT_PASSWORD=root \\\n   mysql:5.7\n   ```\n","tags":["docker"],"categories":["运维"]},{"title":"Nodejs交互以及跨域问题","url":"/2024/02/03/Nodejs交互以及跨域问题/","content":"\n### Nodejs跨域问题\n\n- 使用CORS（主要）\n- 使用Jsonp（只支持get请求）\n\n------\n\n#### cors：\n\n- npm install cors（安装cors中间件）\n- const cors = require('cors')\n- 调用 app.use(cors())配置中间件\n\n#### Jsonp（具体实现）:\n\n1. 得到函数的名称\n2. 定义要发送的到客户端的数据对象\n3. 用模板字符串拼接出一个函数的调用\n4. 返回响应\n\n```js\n//补充:jsonp实现 (本质利用了script的可跨域特性)\n\napp.get('api/jsonp', (req, res) => {\n\n    const funcName = req.query.callback;\n\n    const data = { name: 'zhangsan', age: 18 }\n\n    const scriptStr = `${funcName}(${JSON.stringify(data)})`\n\n    res.send(scriptStr);\n})\n```\n\n","tags":["Node.js"],"categories":["后端"]},{"title":"'Nodejs:Express与Web开发'","url":"/2024/01/26/Nodejs-Express与Web开发/","content":"\n### Express模块\n\n- express是基于Nodejs的用于快速搭建Web平台的包\n\n**示例**\n\n```js\nconst express = require(\"express\")\n\n//利用express创建服务器\nconst app = express();\n\n//启动服务器，监听80端口\napp.listen(80, () => {\n    console.log(\"server running in http://127.0.0.1\");\n})\n\n//监听客户端的Get和Post请求，向客户端响应具体内容\napp.get(\"/user\", (req, res) => {\n    //send()用于响应\n    res.send({\n        name: \"zs\",\n        age: 20\n    })\n})\n\napp.post(\"/user\", (req, res) => {\n    //send()用于响应\n    res.send(\"post succeed\");\n})\n```\n\n- 通过req.query对象，访问到客户端发来的字符串参数\n\n```js\napp.get(\"/\", (req, res) => {\n    console.log(req.query);\n})\n```\n\n- 通过req.params对象，直接接收动态参数\n\n```js\napp.get(\"/user/:id\", (req, res) => {\n    //直接将发过来的参数作为动态的id值，id就是这个参数的名字\n    console.log(req.params);\n    res.send(req.params);\n})\n```\n\n**结果：**\n\n![](Nodejs-Express与Web开发/express.png)\n\n*注：多个参数*\n\n```js\napp.get(\"/user/:id/:name\", (req, res) => {\n    res.send(req.params);\n})\n```\n\n![](Nodejs-Express与Web开发/express2.png)\n\n------\n\n#### express的静态资源\n\n![](Nodejs-Express与Web开发/express3.png)\n","tags":["Node.js"],"categories":["后端"]},{"title":"Node.js模块化","url":"/2024/01/26/Node-js模块化/","content":"\n### Nodejs模块化处理\n\n------\n\n1.js中module对象的用法：\n\n![](Node-js模块化/模块化_1.png)\n\n2.使用require()模块导入结果时,永远以**module.exports指向的对象**为准打印输出:\n\n![](Node-js模块化/模块化_2.png)\n\n------\n\n### Export\n\n*注:Nodejs提供了exports对象，默认情况下，exports和module.export指向同一个对象*\n\n1. 永远记得，require()永远得到的是module.exports指向的对象\n\n   ![](Node-js模块化/exports.png)\n\n2. 为了防止混乱，建议不要在一个项目中同时使用exports和module.exports\n","tags":["Node.js"],"categories":["后端"]},{"title":"element多级菜单组件封装","url":"/2022/07/11/element多级菜单组件封装/","content":"\n### 父组件的封装\n\n```vue\n<template>\n  <div id=\"sidebar_box\">\n    <el-radio-group v-model=\"isCollapse\" style=\"margin-bottom: 20px;\">\n      <el-radio-button :label=\"false\">展开</el-radio-button>\n      <el-radio-button :label=\"true\">收起</el-radio-button>\n    </el-radio-group>\n\n    <el-menu class=\"el-menu-vertical-demo box-content shadow-lg\" :collapse=\"isCollapse\">\n      <SubMenu v-for=\"(item,index) in menuList\" :key=\"index\" :node=\"item\"></SubMenu>\n    </el-menu>\n  </div>\n</template>\n\n<script>\nimport SubMenu from \"@/components/SubMenu.vue\";\nimport { getRouterInfo } from \"@/api/UserApi/loginApi\";\nimport { getToken } from \"@/utils/auth\";\n\nexport default {\n  name: \"SideBar\",\n  props: {},\n  data() {\n    return {\n      isCollapse: false,\n      menuList: [],\n    };\n  },\n```\n\n### 模板数据\n\n```json\nmenuList: [\n        {\n          index: \"1\",\n          hasChildren: false,\n          name: \"首页\",\n          path: \"/Home\",\n          icon: \"el-icon-location\",\n        },\n        {\n          index: \"2\",\n          hasChildren: false,\n          name: \"楼宇管理\",\n          path: \"/BuildingManagement\",\n          icon: \"el-icon-office-building\",\n        },\n        {\n          index: \"3\",\n          hasChildren: false,\n          name: \"设备管理\",\n          path: \"/EquipmentManagement\",\n          icon: \"el-icon-s-platform\",\n        },\n        {\n          index: \"4\",\n          hasChildren: true,\n          name: \"门禁管理\",\n          path: \"/AccessManagement\",\n          icon: \"el-icon-s-tools\",\n          childrenList: [\n            {\n              index: \"4-1\",\n              hasChildren: false,\n              name: \"门禁控制\",\n              path: \"/AccessControl\",\n              icon: \"el-icon-coordinate\",\n            },\n            {\n              index: \"4-2\",\n              hasChildren: false,\n              name: \"历史记录\",\n              path: \"/AccessHistory\",\n              icon: \"el-icon-document\",\n            },\n          ],\n        },\n      ],\n```\n\n\n\n- 父组件需要判断数组数据是否含有子元素\n\n- 若有子元素则需要调用多级菜单**el-submenu**\n\n  ------\n\n### 子组件引入\n\n```javascript\nimport SubMenu from \"@/components/SubMenu.vue\";\n```\n\n### 子组件结构\n\n```vue\n<template>\n  <div id=\"menu_box\">\n    <el-menu-item v-if=\"node.children==null||node.children.length==0\" :index=\"node.name\">\n      <i :class=\"node.meta.iconCls\"></i>\n      <span slot=\"title\">\n        <router-link :to=\"node.path\" class=\"router_click\">{{node.meta.title}}</router-link>\n      </span>\n    </el-menu-item>\n\n    <el-submenu v-else :index=\"node.name\">\n      <template slot=\"title\">\n        <i :class=\"node.meta.iconCls\"></i>\n        <span slot=\"title\" class=\"router_click\">{{node.meta.title}}</span>\n      </template>\n      <el-menu-item-group>\n        <SubMenu v-for=\"(item,index) in node.children\" :key=\"index\" :node=\"item\" :index=\"node.name\"></SubMenu>\n      </el-menu-item-group>\n    </el-submenu>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"SubMenu\",\n  props: [\"node\"],\n  data() {\n    return {};\n  },\n```\n\n- 子组件与父组件结构类似同样需要进行判断\n- 不同之处在于子组件需要自身嵌套\n- 另外一点是子组件需要接收父组件发送的有子元素的数据的信息，通过props接收\n\n### 接收子组件参数\n\n```Vue\nname: \"SubMenu\",\nprops: [\"node\"]\n```\n\n### 自身调用\n\n```Vue\n<el-menu-item-group>\n    <SubMenu v-for=\"(item,index) in node.children\" :key=\"index\" :node=\"item\" :index=\"node.name\">\t\t\t\t</SubMenu>\n</el-menu-item-group>\n```\n\n- 组件调用自身不需要引入，直接使用同name作为标签即可\n\n#### 下面是效果图，模板数据为上文给出的：\n\n![](element多级菜单组件封装/菜单封装.png)\n","tags":["Vue"],"categories":["前端"]},{"title":"Vue双向绑定及数据代理底层原理","url":"/2022/06/22/Vue双向绑定及数据代理底层原理/","content":"\n## Vue双向绑定及数据代理底层原理\n\n​\tvue数据的双向绑定是通过数据劫持结合**发布者-订阅者模式**的方式来实现的。其核心就是通过**Object.defineProperty()**方法设置**set**和**get**函数来实现数据的劫持，在数据变化时发布消息给订阅者，触发相应的监听回调。也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；\n\n### Object.defineProperty()方法\n\n​\tObject.defineProperty(obj, prop, descriptor) ，这个语法内有三个参数，分别为 obj （要定义其上属性的对象）； prop （要定义或修改的属性）； descriptor （具体的改变方法） 简单地说，就是用这个方法来定义一个值。当调用时我们使用了它里面的get方法。当给这个属性赋值时，就调用了它里面的set方法；\n\n**具体实现：**\n\n#### Object.defineProperty()\n\n```javascript\nvar man = {\n    name: 'zhangsan',\n    sex: '男'\n}\n\n Object.defineProperty(man, 'age', {\n     value: 20,\n     enumerable: true, //可枚举属性，默认值是false\n     writable: true, //控制是否可被修改，默认值是false\n     configurable: true, //控制是否可被删除，默认值是false\n })\n\nconsole.log(man) // { name: 'zhangsan',sex: '男' , age:20 }\n```\n\n------\n\n**数据双向绑定 （数据响应式）**\n\n```javascript\nvar nowAge = 20;\nvar man = {\n    name: 'zhangsan',\n    sex: '男',\n    //age: 18\n}\n\n//console.log(Object.keys(man)); \n\n//定义对象的属性\nObject.defineProperty(man, 'age', {\n    // value: Number,\n    enumerable: true, //可枚举属性，默认值是false\n    // writable: true, //控制是否可被修改，默认值是false\n    configurable: true, //控制是否可被删除，默认值是false\n\n    //当有人读取man的age属性时，get函数(getter)就会被调用，且返回值就是age的值（双向绑定原理）\n    get: function() {\n        console.log('有人读取age属性叻');\n        return nowAge\n    },\n    //当有人修改man的age属性时，get函数(getter)就会被调用，且返回值就是age的值（双向绑定原理）\n    set(val) {\n        console.log(\"有人修改了age的值，现在值为：\", val);\n    }\n})\n\nconsole.log(man);\n```\n\n------\n\n**Vue中的数据代理与劫持**\n\n1.  <u>通过vm对象来代理data对象中属性的操作（读/写)</u>\n2. <u>Vue中数据代理的好处：更加方便的操作data中的数据(响应式)</u>\n3. <u>核心原理：通过object.defineProperty()把data对象中所有属性添加到vm上。为每一个添加到vm上的属性,都指定一个getter/setter。在getter/setter内部去操作（读/写)data中对应的属性。</u>\n\n------\n\n### 示意图：\n\n![](Vue双向绑定及数据代理底层原理/双向绑定.png)\n\n\n\n![](Vue双向绑定及数据代理底层原理/双向绑定原理.png)\n\n\n\n### <u>关于Vue的双向绑定和数据代理就讲到这咯~~~</u>\n","tags":["前端知识点"],"categories":["前端"]},{"title":"Three.js导入外部3D模型","url":"/2021/11/24/Three-js导入外部3D模型/","content":"\n### 首先引入两个库\n\n------\n\n```js\n<script src=\"http://www.yanhuangxueyuan.com/threejs/examples/js/loaders/OBJLoader.js\"></script>\n    <script src=\"http://www.yanhuangxueyuan.com/threejs/examples/js/loaders/MTLLoader.js\"></script>\n```\n\nTHREE.MTLLoader()函数说明：\n\n- `mtlLoader.setBaseUrl()`：设置材质路径\n- `mtlLoader.setPath()`：设置mtl文件所在路径\n- `mtlLoader.load(filename,onSuccess(materials ),onProgress(xhr),onError(error))`：mtl文件名、 加载成功后回调处理(参数为生成的材质库)、加载过程中回调处理(xhr对象属性可计算出已完成加载百分比)、失败回调处理\n\nTHREE.OBJLoader() 函数说明：\n\n- `objLoader.setMaterials( materials )`：设置obj使用的材质贴图\n- `objLoader.setPath( options.objPath )`：设置obj文件所在路径\n- `objLoader.load( filename,onSuccess(object ),onProgress(xhr),onError(error))`：obj文件名、 加载成功后回调处理(参数为生成的三维对象)、加载过程中回调处理(xhr对象属性可计算出已完成加载百分比)、失败回调处理。\n\n在onSuccess(object ){}回调里我们可以对生成的三维对象做一些处理：对材质进行调色、设置透明度、设置贴图模式等，对设置旋转、缩放、位置摆放、自发光颜色、环境光颜色。\n如果obj文件代表的三维对象是由多个子模型构成的模型组合，我们可以调用object.traverse(function(child){})来对每个子模型进行处理。\n以下简单封装成一个函数\n\n```js\nfunction createMtlObj(options){\n//      options={\n//          mtlBaseUrl:\"\",\n//          mtlPath:\"\",\n//          mtlFileName:\"\",\n//          objPath:\"\",\n//          objFileName:\"\",\n//          completeCallback:function(object){  \n//          }\n//          progress:function(persent){\n//              \n//          }\n//      }\n    THREE.Loader.Handlers.add( /\\.dds$/i, new THREE.DDSLoader() );\n    var mtlLoader = new THREE.MTLLoader();\n    mtlLoader.setBaseUrl( options.mtlBaseUrl );//设置材质路径\n    mtlLoader.setPath( options.mtlPath );//设置mtl文件路径\n    mtlLoader.load( options.mtlFileName, function( materials ) {\n        materials.preload();\n        var objLoader = new THREE.OBJLoader();\n        objLoader.setMaterials( materials );//设置三维对象材质库\n        objLoader.setPath( options.objPath );//设置obj文件所在目录\n        objLoader.load( options.objFileName, function ( object ) {\n             \n             \n            if(typeof options.completeCallback==\"function\"){\n                options.completeCallback(object);\n            }\n        }, function ( xhr ) {\n            if ( xhr.lengthComputable ) {\n                var percentComplete = xhr.loaded / xhr.total * 100;\n                if(typeof options.progress ==\"function\"){\n                    options.progress( Math.round(percentComplete, 2));\n                }\n                //console.log( Math.round(percentComplete, 2) + '% downloaded' );\n            }\n        }, function(error){\n             \n        });\n \n    });\n}\n```\n\n调用实例：\n\n```js\ncreateMtlObj({\n    mtlBaseUrl:\"../resource/haven/\",\n    mtlPath: \"../resource/haven/\",\n    mtlFileName:\"threejs.mtl\",\n    objPath:\"../resource/haven/\",\n    objFileName:\"threejs.obj\",\n    completeCallback:function(object){\n        object.traverse(function(child) { \n            if (child instanceof THREE.Mesh) { \n                child.material.side = THREE.DoubleSide;//设置贴图模式为双面贴图\n                child.material.emissive.r=0;//设置rgb通道R通道颜色\n                child.material.emissive.g=0.01;//设置rgb通道G通道颜色\n                child.material.emissive.b=0.05;//设置rgb通道B通道颜色\n                child.material.transparent=true;//材质允许透明\n                //child.material.opacity=0;//材质默认透明度                        \n                //child.material.shading=THREE.SmoothShading;//平滑渲染\n            }\n        });\n        object.emissive=0x00ffff;//自发光颜色\n        object.ambient=0x00ffff;//环境光颜色\n//      object.rotation.x= 0;//x轴方向旋转角度\n        object.position.y = 0;//位置坐标X\n        object.position.z = 0;//位置坐标y\n        object.scale.x=1;//缩放级别\n        object.scale.y=1;//缩放级别\n        object.scale.z=1;//缩放级别\n        object.name=\"haven\";//刚体名称\n        object.rotation.y=-Math.PI;//初始Y轴方向旋转角度\n        scene.add(object);//添加到场景中\n    },\n    progress:function(persent){\n         \n        $(\"#havenloading .progress\").css(\"width\",persent+\"%\");\n    }\n})\n```\n\n","tags":["Three.js"],"categories":["前端"]},{"title":"Springboot配置文件以及自动装配","url":"/2021/11/24/Springboot配置文件以及自动装配/","content":"\n# 一.SpringBoot配置文件以及自动配置原理\n\n## 配置文件\n\nSpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的\n\n- application.properties\n  - 语法结构 ： key=value\n- application.yml\n  - 语法结构 ：key：空格 value\n\n**配置文件的作用 ：**修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；**\n**\n\n## YAML\n\nYAML是 \"YAML Ain't a Markup Language\" （YAML不是一种置标语言）的递归缩写。\n\n在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种置标语言）\n\nYAML A Markup Language ：是一个标记语言\n\nYAML isnot Markup Language ：不是一个标记语言\n\n**标记语言**\n\n 以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml\n\nyaml配置：\n\n```\nserver：\n    prot: 8080\n```\n\nxml配置：\n\n```\n<server>\n    <port>8081<port>\n</server>\n```\n\n### YAML语法\n\n**基础语法：**\n\n```\nk:(空格) v   \n```\n\n以此来表示一对键值对（空格不能省略）；以空格的缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。\n\n注意 ：属性和值的大小写都是十分敏感的。例子：\n\n```\nserver:\n    port: 8081\n    path: /hello\n```\n\n### **值的写法**\n\n**字面量：普通的值 [ 数字，布尔值，字符串 ]**\n\n```\nk: v\n```\n\n字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；\n\n“” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；\n\n比如 ： name: \"kuang \\n shen\"  输出 ： kuang 换行  shen\n\n'' 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出\n\n比如 ： name: ‘kuang \\n shen’  输出 ： kuang \\n  shen\n\n \n\n**对象、Map（键值对）**\n\n```\nk: \n    v1:\n    v2:\n```\n\n \n\n在下一行来写对象的属性和值得关系，注意缩进；比如：\n\n```\nstudent:\n    name: qinjiang\n    age: 3\n```\n\n行内写法\n\n```\nstudent: {name: qinjiang,age: 3}\n```\n\n \n\n**数组（ List、set ）**\n\n用 - 值表示数组中的一个元素,比如：\n\n```\npets:\n - cat\n - dog\n - pig\n```\n\n行内写法\n\n```\npets: [cat,dog,pig]\n```\n\n### 修改SpringBoot的默认端口号\n\n 配置文件中添加，端口号的参数，就可以切换端口；\n\n```\nserver.port=8081\n```\n\n## 注入配置文件\n\n### 程序实现\n\n**1. 如果要使用properties配置文件可能导入时存在乱码现象 ， 需要在IDEA中进行调整 ， 我们这里直接使用yml文件 ， 将默认的 application.properties后缀修改为yml** \n\n**![img](https://img2018.cnblogs.com/blog/1418974/201907/1418974-20190728162138583-1678681762.png)**\n\n \n\n**2. 导入配置文件处理器**\n\n**spring默认使用yml中的配置，但有时候要用传统的xml或properties配置，就需要使用spring-boot-configuration-processor了**\n\n```\n<!--导入配置文件处理器，配置文件进行绑定就会有提示-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n    <optional>true</optional>\n</dependency>\n```\n\n\n\n **3.编写yml 配置文件**\n\n\n\n```\nperson:\n    name: qinjiang\n    age: 3\n    happy: false\n    birth: 2000/01/01\n    maps: {k1: v1,k2: v2}\n    lists:\n      - code\n      - girl\n      - music\n    dog:\n      name: 旺财\n      age: 1\n```\n\n\n\n **4.在SpringBoot的主程序的同级目录下建包，只有这样，主程序才会对这些类生效 ； 我们建一个pojo的包放入我们的Person类和Dog类；**\n\n```\npackage com.kuang.springbootdemo03.pojo;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n\n\n/*\n@ConfigurationProperties作用：\n将配置文件中配置的每一个属性的值，映射到这个组件中；\n告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定\n参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应\n\n只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能\n*/\n@Component //注册bean\n@ConfigurationProperties(prefix = \"person\")\npublic class Person {\n\n    private String name;\n    private Integer age;\n    private Boolean happy;\n    private Date birth;\n    private Map<String,Object> maps;\n    private List<Object> lists;\n    private Dog dog;\n\n    //get,set方法\n    //toString方法\n    \n}\n```\n\n```\npackage com.kuang.springbootdemo03.pojo;\n\npublic class Dog {\n    private String name;\n    private Integer age;\n    \n    //get、set方法\n    //toString()方法  \n}\n```\n\n**5.确认无误后，到测试单元中进行测试，看是否注入成功！**\n\n```\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringbootDemo03ApplicationTests {\n\n    @Autowired\n    Person person = new Person();\n\n    @Test\n    public void contextLoads() {\n        System.out.println(person);\n    }\n\n}\n```\n\n \n\n**运行结果**\n\n![img](https://img2018.cnblogs.com/blog/1418974/201907/1418974-20190728163527890-382471618.png)\n\n### 唠叨两句\n\n我们上面采用的方法都是最简单的方式，开发中最常用的；\n\n那我们来唠唠其他的实现方式，道理都是相同得；写还是那样写；\n\n配置文件除了yml还有我们之前常用的properties ， 我们没有讲 ， properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；\n\nsettings-->FileEncodings 中配置；\n\n![img](https://img2018.cnblogs.com/blog/1418974/201907/1418974-20190728164337141-1866486258.png)\n\n还有，我们的类和配置文件直接关联着 ， 我们使用的是@configurationProperties的方式，还有一种方式是使用@value\n\n```\n@Component //注册bean\npublic class Person {\n    //直接使用@value\n    @Value(\"${person.name}\") //从配置文件中取值\n    private String name;\n    @Value(\"#{11*2}\")  //#{SPEL} Spring表达式\n    private Integer age;\n    @Value(\"true\")  // 字面量\n    private Boolean happy;\n    \n    。。。。。。  \n}\n```\n\n**结果**\n\n![img](https://img2018.cnblogs.com/blog/1418974/201907/1418974-20190728170012915-2055615871.png)\n\n \n\n这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图\n\n![img](https://img2018.cnblogs.com/blog/1418974/201907/1418974-20190728164637719-1038154879.png)\n\n-  cp只需要写一次即可 ， value则需要每个字段都添加\n- 松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定\n- JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性\n- 复杂类型封装，yml中可以封装对象 ， 使用@value就不支持\n\n **结论：**\n\n- 配置yml和配置properties都可以获取到值 ， 强烈推荐 yml\n- 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value\n- 如果说，我们专门编写了一个JavaBean来和配置文件进行映射，就直接使用@configurationProperties，不要犹豫！\n\n###  JSR303数据校验\n\nspring-boot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式\n\n```\n@Component //注册bean\n@ConfigurationProperties(prefix = \"person\")\n@Validated  //数据校验\npublic class Person {\n\n    //@Value(\"${person.name}\")\n    @Email //name必须是邮箱格式\n    private String name;\n}\n```\n\n**运行结果** \n\n ![img](https://img2018.cnblogs.com/blog/1418974/201907/1418974-20190728170423075-754365376.png)\n\n**使用数据校验，可以保证数据的正确性；**\n\n###  加载指定配置文件\n\n **1. @PropertySource ：**加载指定的配置文件；使用@configurationProperties默认从全局配置文件中获取值；\n\n我们去在resources目录下新建一个**person.properties**文件\n\n```\nname=kuangshen\n```\n\n然后在我们的代码中指定加载person.properties文件\n\n```\n@PropertySource(value = \"classpath:person.properties\")\n@Component //注册bean\npublic class Person {\n\n    @Value(\"${name}\")\n    private String name;\n\n    ......  \n}\n```\n\n**测试结果：**\n\n![img](https://img2018.cnblogs.com/blog/1418974/201907/1418974-20190728173752209-1527374517.png)\n\n \n\n### 配置文件占位符\n\n**随机数**\n\n```\n${random.value}、${random.int}、${random.long}、${random.int(10)}等等\n```\n\n \n\n**占位符引用其他属性的值，如果不存在可以设置默认值**\n\n```\nperson:\n    name: qinjiang${random.uuid}\n    age: ${random.int}\n    happy: false\n    birth: 2000/01/01\n    maps: {k1: v1,k2: v2}\n    lists:\n      - code\n      - girl\n      - music\n    dog:\n      name: ${person.hello:hello}_旺财\n      age: 1\n```\n\n## 多环境切换\n\nprofile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；\n\n**方式一：多配置文件**\n\n我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml ， 用来指定多个环境版本；\n\n例如：application-test.properties 代表测试环境配置  application-dev.properties 代表开发环境配置\n\n但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件；\n\n我们需要通过一个配置来选择需要激活的环境；\n\n```\n#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；\n#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；\nspring.profiles.active=dev\n```\n\n \n\n**方式二：yml的多文档块**\n\n和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了\n\n```\nserver:\n  port: 8081\n#选择要激活那个环境块\nspring:\n  profiles:\n    active: prod\n\n---\nserver:\n  port: 8083\n#配置环境的名称\nspring:\n  profiles: dev\n\n\n---\n\nserver:\n  port: 8084\nspring:\n  profiles: prod  #配置环境的名称javascript:void(0);)\n```\n\n**注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！**\n\n###  **配置文件加载位置**\n\n**springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件**\n\n```\n优先级1：项目路径下的config文件夹配置文件\n优先级2：项目路径下配置文件\n优先级3：资源路径下的config文件夹配置文件\n优先级4：资源路径下配置文件\n```\n\n优先级由高到底，高优先级的配置会覆盖低优先级的配置；\n\n**SpringBoot会从这四个位置全部加载主配置文件；\\**互补配置\\**；**\n\n**我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；**\n\n```\n#配置项目的访问路径\nserver.servlet.context-path=/kuang\n```\n\n\n\n我们还可以通过spring.config.location来改变默认的配置文件位置\n\n项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；\n\n这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高\n\n```\njava -jar spring-boot-config.jar --spring.config.location=F:/application.properties\n```\n\n \n\n**外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！**\n","tags":["后端开发"],"categories":["文章"]},{"title":"Git上传-更新代码","url":"/2021/11/24/Git上传-更新代码/","content":"\n1. **git init 初始化本地仓库**\n2. **使用git remote add origin https://gitee.com/你的码云用户名/XXXX //添加远程仓库**\n3. **git pull origin master**\n4. **使用git add . （. 表示所有的）或者 git add + 文件名 // 将文件保存到缓存区**\n5. **使用git commit -m '新添加的文件内容描述' //添加文件描述**\n6. **使用git push origin master ，将本地仓库推送到远程仓库**\n\n","tags":["开发"],"categories":["文章"]},{"title":"XiaoXue-小雪 分享一二","url":"/2021/11/22/XiaoXue-小雪-温柔的句子/","content":"\n![](XiaoXue-小雪-温柔的句子/小雪.jpg)\n\n1. <u>**“虽然辛苦 我还是会选择那种滚烫的人生 ”**</u>\n2. <u>**岁月很长，人海茫茫，不要回头，不要将就。 跌跌撞撞才明白了许多，舍不得却又无可奈何。 化热烈的妆，见喜欢的人，做向往的梦。 书上说，总有一个人认你觉得人间值得。 给生活一个微笑，道路还在继续。**</u>\n3. <u>**我希望你被打磨 永远光明磊落 我希望你能走过山山水水 写温柔的字 坦荡地爱 我希望你被阅读 不被辜负 你要飘摇着美丽 活得丰盛 或庄重。**</u>\n4. <u>**读书不是为了雄辩和驳斥，也不是为了轻信和盲从，而是为了思考和权衡。很多人觉得他们在思考，而实际上他们只是在重新整理自己的偏见。**</u>\n5. <u>**无论你现在多难 能不能去看你想去的风景 都不用担心 你力所能及的地方 一定会带给你预想不到的惊喜 你会遇见一些人觉得相见恨晚 或者遇到一个人觉得在那里值得 这是命 遇见你该遇见的 接受你所不能改变的其实不错 生活的迷人之处 不是如愿以偿 而是阴差阳错。**</u>\n6. <u>**人向前走 苦才会退后**</u>\n7. <u>**你必须培养一些爱好，不要空洞遥远的目标而是实在甚至庸俗的吃喝拉撒。必须一觉醒来很清楚至少今天还能干什么。去楼下最辣的粉店吃早饭，去给窗台上的盆栽浇水，去追一集刚更新的新番，去找一个知心老友唠嗑。你必须积攒这种微小的期待和快乐，这样才不会被遥不可及的梦和无法掌控的爱给拖垮。**</u>\n8. <u>**“ 很荣幸能陪你走过这样一段路，以后你不管是大红大紫还是泯然众人，我都记得在今年的这个暮冬到初春，我见证过你眼里有光并也认为前路有光的时刻。祝你，永远一帆风顺，永远是少年 ”**</u>\n9. <u>**被一个人深深地爱着，将给你力量，而深深地爱着一个人，将给你勇气。**</u>\n10. <u>**外向是生活所需，孤独才是自我享受。**</u>\n11. <u>**生活总会给你答案，但不会马上把一切都告诉你。**</u>\n12. <u>**西蒙娜波伏娃给萨特的《越洋情书》写着：“我渴望能见你一面， 但请你记得， 我不会开口要求要见你。 这不是因为骄傲， 你知道我在你面前毫无骄傲可言， 而是因为， 唯有你也想见我的时候， 我们见面才有意义。”**</u>\n\n","tags":["第二场电影"],"categories":["特别场次"]},{"title":"《个人日报:2021-08-21》","url":"/2021/08/21/2021-08-21/","content":"\n------\n\n### **不定参数 arguments:**\n\n * **他是函数内部的一个成员，只要在函数执行的时候才会存在**\n * **他接收的是传递进来的所有实参**\n * **arguments 拿到的是一个类数组，包含所有的实参，他不影响其它形参的接收**\n * **模板：**\n\n```js\n function fun() {\n            console.log(arguments); //不定参数 [传入参数1,传入参数2,传入参数3]\n        }\n        fun(1, 2, 3)\n```\n\n**举例：**\n\n```js\nfunction sum() {\n            let su = 0\n            for (let i = 0; i < arguments.length; i++) {\n                if (typeof arguments[i] === 'number') {\n                    su += arguments[i]\n                }\n            }\n            console.log(su);\n        }\n\n        sum(123, 213, 32123, 213, 231, 2, 321, '123')\n\n```\n\n * **总结：**\n   \t* **总结：不定参数arguments常用于接收实参数量不确定的时候**\n\n------\n\n### **不定参数 ...rest:**\n\n * **...rest 参数**\n * **...rest 剩余的意思，他代表的是剩余参数，用于参数不确定的情况，我们可以使用rest来接受剩下的所有参数**\n * **...rest 接收到的是一个标准的数组，数组里面存放的是所有实参的值**\n * **...rest 参数必须放在最后一个形参的位置**\n * **rest只是一个变量名，这里便于理解，当然换成aaa,bbb,ccc都没问题**\n * **模板：**\n\n```js\nfunction log(num, ...rest) {\n            console.log(num);\n            console.log(rest);\n        }\n\n        log(1, 2, 3, 4, 5, 6);\n```\n\n**举例：**\n\n```js\n//封装一个函数，传入一堆数值，返回数值里面最大的一个值\n        function findMax(...rest) {\n            let len = rest.length\n            let max = -Infinity //预存一个最小值\n            for (let i = 0; i < len; i++) {\n                if (rest[i] > max) {\n                    max = rest[i]\n                }\n            }\n            return max\n        }\n\nconsole.log(findMax(123, 132, 1321, 321123, 12, 312, 31, 321, 1, 321, 321, 321));\n```\n\n------\n\n### **纯函数：**\n\n\t* 函数的执行只依赖于自己内部的参数和变量，最终返回的值不会改变函数外部的值\n\t* 这种函数称为纯函数\n\n**举例：**\n\n```js\n//补0函数 \n        function padLeft(num) {\n            // return String(num)[1] && String(num) || '0' + num\n            return String(num)[1] ? num : '0' + num\n        }\n        console.log(padLeft(5));\n```\n\n### **非纯函数：**\n\n**举例：**\n\n```js\nlet str = 'IU'\n\n    function changeStr() {\n        str = '李知恩'\n    }\nchangeStr()\nconsole.log(str);\n```\n\n------\n\n### **匿名函数：**\n\n * **意如其名，即没有名字的函数**\n * **用()包裹没有命名的函数，表示直接执行这个函数**\n\n**举例：**\n\n```js\n (function() {\n            console.log(1);\n        })\n\n```\n\n------\n\n### **箭头函数：**\n\n\t* 一般函数变为箭头函数\n\t* 举例：\n\n```js\nlet fn = function() {\n            console.log(\"函数执行了\");\n        }\n\n        //改为箭头函数 \n        //无变量的情况\n        let fn2 = () => {\n            console.log(\"函数执行了\");\n        }\n        fn2()\n```\n\n#### **箭头函数的简写规则：**\n\n * **当无形参时，只需将普通函数的 function 和 ( ) 省略为一个括号即可**\n * **当有一个形参时，可直接只保留一个形参**\n * **当有两个及以上参数时，需要完整写为(参数1,参数2,......)的形式**\n * **当只有一条语句时，{}也可以不加 return也要去掉，表示函数直接返回这条语句(<u>所有函数写法都适用这条规则</u>)**\n * **可以使用 ()和,的方式简写代码块(<u>所有函数写法都适用这条规则</u>)**\n * **下面举个栗子：**\n\n```js\n        //有一个变量的情况\n        function padLeft(num) {\n            return String(num)[1] ? num : '0' + num\n        }\n        let fn3 = (num) => {\n            return String(num)[1] ? num : '0' + num\n        }\n\n        //当只有一个参数的时候，可以不加括号\n        let fn33 = num => {\n            return String(num)[1] ? num : '0' + num\n        }\n\n        //当只有一条语句时，{}也可以不加 return也要去掉，表示函数直接返回这条语句\n        let fn333 = num => String(num)[1] ? num : '0' + num;\n\n        let fn4 = function(a, b) {\n            console.log(a, b);\n            return (a + b) / 2\n        }\n        console.log(fn4(6, 6));\n        let fn6 = (a, b) => (console.log(a, b, 'log执行'), (a + b) / 2)\n        console.log(fn6(5, 7));\n\n\n```\n\n------\n\n### **其他函数：**\n\n\t* 除此之外，还有一些特殊的函数\n\t* 例如：柯里化函数，递归函数，偏函数，构造函数，闭包函数，通道函数\n * **下面以柯里化函数举个例子**\n   \t* **柯里化函数，即函数返回函数**\n      \t*** 讲得那么高级，实际上就是返回值为一个函数**\n\n```js\n\t\t//柯里化函数 函数返回函数\n        function curr(x) {\n            return function(y) {\n                console.log(x + y);\n            }\n        }\n\n        let fnfn = curr(10)\n        fnfn(20)\n\n\t\tlet fnn = function() {\n                console.log(1)\n                return function() {\n                    console.log(2)\n                    return function() {\n                        console.log(3)\n                    }\n                }\n            }\n            //如何打印出 3 \n\n        fnn()()()\n```\n\n------\n\n### **最后分享一个数组操作方法：**\n\n\t* 要求如下：\n\t* 原数组 let arr = ['a', 'b', 'c', 'd', 'e']\n\t* 要求返回一个新数组，新数组的值，是原来数组每个值下标往后面偏移两个后的值\n\t* 期望值 let newArr = ['c','d','e','a','b']\n\t* 要求不使用数组操作方法\n\n#### **代码如下**\n\n```js\nlet arr = ['a', 'b', 'c', 'd', 'e']\n        let answer = (arr) => {\n            let newArr = []\n            for (let i = 0; i < arr.length; i++) {\n                newArr[i] = arr[(i + 2) % arr.length]\n            }\n            return newArr\n        }\n        console.log(answer(arr));\n```\n\n * **具体思路是通过，for循环将每一个下标对印的元素后置两位，若超出数组长度，则置位到起点下标，这里选择使用 % 取余的方法，保证每次循环将最后几个元素，巧妙地分配到前几位。**\n\n\n\n","tags":["个人日报"],"categories":["文章"]},{"title":"《个人日报:2021-08-19》","url":"/2021/08/19/2021-08-19/","content":"\n------\n\n### JS中的特殊循环：\n\n * for-in循环\n    * for-in 是一种特殊的循环 可以循环数组和对象 \n    * 语法： for (let **key**(对应的对象的属性名) in **object**(需要循环的对象或数组)){},\n    * 举个例子:\n\n```js\nlet obj = {\n                name: 'IU',\n                age: 18,\n                sex: '女'\n            }\n            //key 为每一个属性名 obj 是对象本身\n        for (let key in obj) {\n            console.log(`属性名是${key},属性值是${obj[key]}`);\n        }\n\n```\n\n输出如下：\n\n![](2021-08-19/forin.png)\n\n * for-of循环\n    * value 对应的是数组里的每一个值,arr 是数组本身\n    * 举个例子：\n\n```js\n let arr = [1, 2, 3, 4, 5]\n            // value 对应的是数组里的每一个值,arr 是数组本身\n        for (let value of arr) {\n            console.log(value);\n        }\n```\n\n输出如下：\n\n![](2021-08-19/forof.png)\n\n### 函数：\n\n\t* 函数的形参  函数声明的时候接受的参数叫做形参\n\t* 函数的实参  函数执行的时候传递的参数叫做实参\n * 书写方式  function 函数名(形参1,形参2,形参3){}\n    函数名(实参1,实参2,实参3)\n    * 形参没有传入实参的时候默认值是undefind\n    * 函数的返回值, 每个函数都一定会有一个返回值\n    * 函数默认的返回值是undefined\n    * retuen 语句执行代表整个函数执行完成\n","tags":["个人日报"],"categories":["文章"]},{"title":"《个人日报:2021-08-18》","url":"/2021/08/19/2021-08-18/","content":"\n------\n\n### **JS运算符：**\n\n * #### == 和 === 的区别以及使用\n\n    * **==用与比较两个数据的值是否相同**\n    * **===不仅比较两个数据的值，也会比较类型是否相同**\n    * **实际开发中，由于传递的数据类型的考虑，===使用率较高**\n\n * #### 位运算\n\n    * **按位非运算，符号 ~**\n\n    * **下面先来看看例子：**\n\n      ```js\n      例如~1的计算步骤：\n      \n      将1(这里叫：原码)转二进制 ＝ 00000001\n      按位取反 ＝ 11111110\n      发现符号位(即最高位)为1(表示负数)，将除符号位之外的其他数字取反 ＝ 10000001\n      末位加1取其补码 ＝ 10000010\n      转换回十进制 ＝ -2\n      ```\n\n   - **按位取反的运算规则这么奇怪并不是JavaScript独有的，而是所有的计算机语言都是这样的。这样做的主要原因是为了为了统一减法和加法，在计算机中，减法会变成加一个负数，而负数会以补码的形式存储。而这样主要是因为补码和数字的十进制数有这么转换关系，负数：`补码(x) = -x - 1`，正数：`补码(x) = x`**\n\n   - **因为补码是针对负数存在的，那么只要数据类型有`无符号数`，就没有这样的烦恼了，比如C语言有无符号整型，就能对无符号整型直接按位取反。**\n\n   - **如果没有无符号类型，而且也只是想要按位取反，而不是附带补码的按位取反，需要另外的方法。让全1的数据和当前数据做按位抑或就行了。比如，你有一个32位的数据a，需要对它做按位取反，那么这样就行了：<u>`0xFFFF ^ a`</u>**\n   - **因为~运算会默认舍去小数部分，因此常用~~来实现去除小数**\n\n   \n\n","tags":["个人日报"],"categories":["文章"]},{"title":"QiXi(七夕):分享一些诗句","url":"/2021/08/14/QiXi-七夕-分享一些诗句/","content":"\n![](QiXi-七夕-分享一些诗句/qixi.jpg)\n\n*I thought I would be the last <u>shadow</u> in your eyes.*\n\n一眼认定你，余生皆是你。\n\n*Between the moon and the snow, lies the <u>beauty</u> of you.*\n\n月色与雪色之间，你是第三种绝色。\n\n*My <u>heart</u> is busy beating for you.*\n\n因为你，我的心脏总是忙个不停。\n\n*I was determed to <u>travel all over the world</u> until I met you.*\n\n我本来是要行走江湖的，但是遇到你，我觉得可以先停一停。\n\n*Repost the phrase <u>“lucky dog”</u>， and you‘ll be in a relationship.*\n\n转发“幸运儿“这个短语，你就会脱单。\n\n*Nothing important lingered in my mind until you <u>appeared</u>.*\n\n在你之前，我没有一件像样的心事。\n\n*“You are the <u>lovelist</u>”, said I by impulse, and I said again upon consideration.*\n\n“你最可爱”，我说时来不及思索，而思索之后，还是这样说。\n\n*I have written you name with <u>every pen</u> of mine.*\n\n我的每一支笔都知道你的名字。\n\n","tags":["第一场电影"],"categories":["特别场次"]},{"title":"《个人日报:2021-08-13》","url":"/2021/08/13/2021-08-13/","content":"\n------\n\n### JS数据在内存中的存储：\n\n![](2021-08-13/js数据在内存中的存储.png)\n\n * #### 基本数据类型\n   \n    *  所有基本数据类型都是存放在栈内存里面\n    *  基本数据类型之间的赋值，直接copy目标变量\n * #### 引用数据类型\n   \n    * 所有引用数据类型的存储，都是在栈中存入指针(相当于地址)，然后指向堆中的某一块内存，里面有相应的数据\n    * 引用数据类型之间的赋值，是copy目标变量的指针，然后在堆中开辟一块内存空间存储目标指针的堆中数据\n    * 相当于共享文档，分享地址值，每个人能够对文档进行修改，但文档在不同的电脑上需要使用不同的展示方式，相当于开辟新的内存空间\n\n------\n\n### 总结：\n\n- **基本数据类型**：声明一个新变量，使用原数据对新数据进行赋值操作，不会影响原数据，因为新数据由原数据参数复制而来\n- **引用数据类型**：声明一个新变量，使用原数据对新数据进行赋值操作，会影响原数据。因为新数据开辟一块堆内存，其参数是通过原数据指针获取而来的。假如对数据进行更改，会直接修改原数据的堆内存。可以看作，相当于原数据和新数据两者共用同一数据源。\n","tags":["个人日报"],"categories":["文章"]},{"title":"《个人日报:2021-08-12》","url":"/2021/08/12/2021-08-12/","content":"\n------\n\n数据类型：\n\n * 基本类型\n    * number 数值类型\n    * string 字符串类型\n    * boolean 布尔类型\n    * undefined 未定义\n    * null 空值\n    * symbol 唯一标识符\n    * bigint 大整数\n * 引用类型\n    * object\n\n### 基本类型\n\n------\n\n#### \t数值类型:\n\n```js\n    // 数值类型:标识数字\n    // 十进制的数值，八进制的数值，十六进制的数值，NaN（计算错误的值）\n    let num1 = 123 //十进制\n    let num2 = 012 //八进制的数值，以0开头，和0-7之间任意数字构成的\n    let num3 = 0x18f //十六进制的数值，以0下开头，和0-9 a-f构成的数值\n\n    //浮点数\n    let num4 = ((0.1 * 10) + (0.2 * 10)) / 10\n    let num5 = 0 / 0 // NaN 代表一个无法计算的错误值\n\n    let num6 = 6e5 // e表示科学计数法，这里e5指10的5次方\n    let num7 = 6 ** 5 // **表示次方，这里6**5表示6的5次方\n\n    //Number.MAX_VALUE 表示js能展示的最大数值\n    //（-）Infinity 无限大，正向（反向）溢出的值\n    console.log(typeof num5); //typeof 用于返回数据的类型\n    console.log(Number.MAX_VALUE);\n```\n\n------\n\n#### \t字符串类型： \n\n```js\n    // 字符串类型:\n\n    // 书写通过 \"\" 或者 ''\n\n    // 另外，`` 是es6新增的字符串方式，叫做模板字符串\n    // 模板字符串里面可以拼接变量 语法：${变量名}\n    // 内部可以自由书写 \"\" 和 '' 不用担心转义问题，非常好用             \n\n    let name = \"李知恩\"\n    let str = \"IU说：\"\n    let say1 = 'IU说：\"不要看别的女生\"'\n    let say2 = `${str}\"不然她要吃醋了\"`\n    \n    let len = say2.length //.length用于获取字符串的长度\n    \n    console.log(say2[5]);//获取字符串的某一个值\n```\n\n------\n\n#### \t布尔类型：\n\n```js\n    //boolean 布尔类型\n    let bol = true\n```\n\n------\n\n#### \t未定义类型：\n\n```js\n    //undefined 未定义\n    //变量声明没有定义就是 undefined    也可以手动定义\n    let und = undefined\n```\n\n------\n\n#### \t空值类型：\n\n```js\n    //null 代表空值，代表这个变量没有存储任何东西\n    let aa = null\n    console.log(aa);\n    console.log(typeof aa); // null 的类型为object\n```\n\n------\n\n#### \t唯一标识符：\n\n```js\n    //symbol 唯一标识符\n    let sym1 = Symbol(1)\n    let sym2 = Symbol(1)\n    console.log(sym1 === sym2); //Symbol永不相等 无法比较\n```\n\n------\n\n#### \t大整数型：\n\n```js\n    //bigint 存储一个能超过最大值限制的值 常用于解决精度缺失的问题\n    //最大限制值只能 和同类型的值相加\n    let bigNumber1 = Number.MAX_VALUE\n    let bigNumber2 = bigNumber1 + 100\n    console.log(bigNumber1 === bigNumber2); //返回值为true，因为不能突破最大值上限\n\n    let a = Number.MAX_SAFE_INTEGER //最大安全值\n    let b = BigInt(a)\n    let c = BigInt(2)\n    console.log(b + c);\n```\n\n### 引用类型\n\n------\n\n#### \t\t对象类型：\n\n```js\n    /* \n             object 对象\n             对象可以当做是一个数据的集合  , 可以存放任意数据类型\n             格式 数据名(变量/键名):数据值(值可以是任意类型 / 键值)\n    */\n\n    let obj1 = new Object();\n\n    //字面量创建\n    let IU = {\n        name : \"李知恩\",\n        age : 18,\n        fred : ['IU1','IU2','IU3','IU4']\n    }\n\n    console.log(IU)\n    // 对象的取值\n    //方式一 : 通过对象.属性名 的方式取值\n    console.log(IU.name)\n    //方式二: 通过下标的方式取值 对象['属性名']\n    let obname = \"fred\"\n    console.log(IU['age']) \n    console.log(IU[obname])\n\n    //对象的赋值和修改值\n    luyao.name = \"IU李知恩\"\n    luyao[\"sex\"] = '女'\n    console.log(IU)\n\n    //需求拿到朱雀\n    console.log(IU.fred[1])\n\n```\n\n------\n\n### \t\t数组：\n\n```js\n    // arr 数组类型\n    //方式一 : 通过包装对象的方式创建\n    let arr = new Array(1,'ni',3,4,5)\n    //方式二:字面量的方式创建数组\n    let arr2 = [1, \"ni\", true, null, \"哈哈\"]\n    console.log(arr2)\n\n    // 数组的简单操作\n    //数组取值  通过下标的方式取值 , 值是从0开始计算\n    let hah = arr2[4]\n    //获取数组的长度\n    console.log(arr2.length) // 获取数组的长度\n\n    let getARr = arr2[5]\n    console.log(getARr) // 取的值超出数组长度拿到的就是undefined\n\n    //数组更改或者新增值\n    arr2[5] = '我是新增的值'\n    arr2[1] = 666\n    console.log(arr2)\n\n    let arr3 = [1,2,3,[4,5,6],7,8,9] // 二维数组\n    console.log(arr3[3][0]) // 多维数组的取值也是一样的取值方式\n\tconsole.log(typeof arr2) //object\n```\n\n------\n\n### 函数：\n\n```js\n    // function 函数\n    // 函数就是一组语句的集合，他是一个独立运行的程序单元，在js里面函数是非常重要的东西\n    // 函数通过 函数体 还有一堆的 组合语句 构成\n    //函数的定义 function 函数名(){\n    //  函数体代码\n    //}\n\n\n    let fn = function() { //定义一个函数名字叫fn\n        //函数体的书写\n        console.log(\"函数执行\");\n    }\n    //函数调用\n    fn()\n```\n\n","tags":["个人日报"],"categories":["文章"]},{"title":"《个人日报:2021-08-11》","url":"/2021/08/11/2021-08-11/","content":"\n------\n\n#### 声明变量：\n\n* **var let const** \n\n  * **var 早期程序员在没有let const出现前一律使用var 现已淘汰 不在建议使用 易引起歧义**\n\n  * **let 用于声明变量，可多次赋值**\n\n  * **const 用以声明常量，定义后不再允许赋值，否则会报错**\n\n    ```json\n    Uncaught SyntaxError: Unexpected identifier\n    ```\n\n- **其中，使用var 对同一个变量进行二次声明，不会报错，而是覆盖前一次的值。但是使用let则会报错**\n\n  ```json\n  Uncaught SyntaxError: Identifier 'name' has already been declared\n  ```\n\n#### **字符串拼接：**\n\n- **直接通过 + 拼接**\n\n#### **字符串转义：**\n\n- **直接通过单双引号（\"   ’ ‘   ''）嵌套使用**\n\n  ```js\n  let iu = 'IU说:\"她吃醋我了\"'\n  let IU = \"IU说:'她吃醋我了'\"\n  ```\n\n- **通过转移符号如 反斜杠将后一个字符取消逻辑意义**\n\n  ```js\n  let iU = 'IU说:\\'她吃我醋了\\''\n  ```\n\n------\n\n**输出结果：**\n\n```html\nIU说:'她吃我醋了'\nIU说:\"她吃我醋了\"\nIU说:'她吃我醋了'\n```\n\n------\n\n**关于HarmonyOS系统开发：**\n\n* **一套app项目能够运行在所有配备了HarmonyOS系统的设备上**\n* **目前支持两种语言进行开发-Java和JavaScript，其中HarmonyOS开发类似于小程序的语法，其生命周期的开发模式可借鉴于Vue的框架**\n* **支持虚拟机运行以及远近程真机调试，只不过需要使用华为账号**\n\n","tags":["个人日报"],"categories":["文章"]},{"title":"《个人日报:2021-08-10》","url":"/2021/08/11/2021-08-10/","content":"\n------\n\n​\t**今天是开始坚持写个人日报的第一天，偶然了解到各位程序员大佬们都有写日报的习惯，因此个人也决定开始写个人日报。**\n\n​\t**今天主要学习了短信验证功能的开发，了解到此功能主要有两种开发思路:**\n\n* **通过服务器开发：此方式实现起来较为复杂，还需要结合后端的知识，因此先避让开**\n\n* **通过网络云短信接口开发：**\n\n  ​\t**此方法比较适合现阶段的我，主要通过发起网络请求，调用云接口的数据，得到响应结果，并向请求中设置的，手机号参数，发送短信，优点是简单快捷，只需要到提供接口的短信平台上注册账号-申请短信模板-获取appId和appSecret便可进行操作**\n\n​    **另外，简单了解了一些关于网页游戏开发的知识，通过Cocos编辑器对cube节点绑定一些脚本事件。**\n\n","tags":["个人日报"],"categories":["文章"]},{"title":"微信小程序-解决不搭建后台服务器实现短信验证","url":"/2021/08/07/小程序短信验证/","content":"\n**自从微信小程序提供云开发支持，开发者无需搭建后台服务器，使用微信提供的核心API就可以实现应用功能，此时就需要小程序能够自己发送短信，比如短信验证码，榛子云短信(http://smsow.zhenzikj.com)为此开发了一套SDK，详情参考: http://smsow.zhenzikj.com/doc/sdk.html**\n\n**如何使用:** \n\n## **1.安装**\n\n**下载后的SDK只包含一个zhenzisms.js文件,可直接放在utils文件夹中，然后通过require引入，如下:**\n\n```java\nvar zhenzisms = require('../../utils/zhenzisms.js');\n```\n\n## **2.配置域名**\n\n**在微信公众平台-小程序管理中配置域名https://smsdeveloper.zhenzikj.com,如下图:**\n\n**使用事先申请的AppId、AppSecret初始化:**\n\n```java\nzhenzisms.client.init(apiUrl, appId, appSecret);\n```\n\n> **apiUrl为请求地址，个人开发者使用https://sms_developer.zhenzikj.com，企业开发者使用https://sms.zhenzikj.com**\n\n## **1)发送短信**\n\n```java\nzhenzisms.client.send(function(res){\n                console.log(res.data);\n              })\n             }, '15811111111', '您的验证码为2323');\n```\n\n**send方法用于单条发送短信**\n\n\n\n**参数1:请求后的用于接收返回结果的回调函数，参数2:接收者手机号码，参数3:短信内容**\n\n****\n\n**返回结果是json格式的字符串, code: 发送状态，0为成功。非0为发送失败，可从data中查看错误信息**\n\n****\n\n**注: 测试发送短信内容不要使用\"你好\"或\"12132\"全数字形式，这种短信内容没有具体的意义，可能会被运营商屏蔽**\n\n```java\n{\n\t\t\t    \"code\":0,\n\t\t\t    \"data\":\"发送成功\"\n\t\t\t}\n```\n\n****\n\n## **2)发送短信(返回状态报告)**\n\n```java\nzhenzisms.client.send(function(res){\n                console.log(res.data);\n              })\n             }, '15811111111', '您的验证码为2323', 'dfee_dfdw_xdfd_dfdfd');\n```\n\n**send方法用于单条发送短信,并且开发者可接受短信发送状态报告**\n\n****\n\n**参数1:请求后的用于接收返回结果的回调函数，参数2:接收者手机号码，参数3:短信内容, 参数4:messageId即该条短信的唯一标识, 不能重复**\n\n****\n\n**返回结果是json格式的字符串, code: 发送状态，0为成功。非0为发送失败，可从data中查看错误信息**\n\n****\n\n**错误代码表**\n\n**错误码 原因 解决方案**\n\n**100 参数格式错误 检查请求参数是否为空, 或手机号码格式错误**\n\n**101 短信内容超过1000字 短信内容过长，请筛检或分多次发送**\n\n**105 appId错误或应用不存在 请联系工作人员申请应用或检查appId是否输入错误**\n\n**106 应用被禁止 请联系工作人员查看原因**\n\n**107 ip错误 如果设置了ip白名单，系统会检查请求服务器的ip地址，已确定是否为安全的来源访问**\n\n**108 短信余额不足 需要到用户中心进行充值**\n\n**109 今日发送超过限额 如果设置了日发送数量，则每个接收号码不得超过这个数量**\n\n**110 应用秘钥(AppSecret)错误 检查AppSecret是否输入错误，或是否已在用户中心进行了秘钥重置**\n\n**111 账号不存在 请联系工作人员申请账号**\n\n**1000 系统位置错误 请联系工作人员或技术人员检查原因**\n\n****\n\n**3)查看余额**\n\n**通过该接口可查看当前剩余的短信条数**\n\n```java\nzhenzisms.client.balance(function(res){\n               console.log(res.data)\n            });\n```\n\n**返回结果是json格式的字符串, code: 查询状态，0为成功，data为剩余短信条数。非0为查询失败，可从data中查看错误信息**\n\n****\n\n**错误代码表**\n\n**错误码 原因 解决方案**\n\n**100 参数格式错误 检查请求参数是否为空**\n\n**105 appId错误或应用不存在 请联系工作人员申请应用或检查appId是否输入错误**\n\n**106 应用被禁止 请联系工作人员查看原因**\n\n**107 ip错误 如果设置了ip白名单，系统会检查请求服务器的ip地址，已确定是否为安全的来源访问**\n\n**110 应用秘钥(AppSecret)错误 检查AppSecret是否输入错误，或是否已在用户中心进行了秘钥重置**\n\n**1000 系统位置错误 请联系工作人员或技术人员检查原因**\n\n**4)查询短信**\n\n## **接口描述**\n\n**根据messageId查询已发送短信**\n\n```java\nzhenzisms.client.findSmsByMessageId(function(res){\n               console.log(res.data)\n            }, 'dfee_dfdw_xdfd_dfdfd');\n```\n\n**请求参数**\n\n**参数名称 必选 类型 描述**\n\n**messageId 是 string 信息id，对应发送短信接口的messageId字段**\n\n**返回结果**\n\n**返回结果是json格式的字符串, code: 查询状态，0为成功。非0为失败，可从data中查看错误信息**\n\n```java\n{\n\t\t\t    \"code\":0,\n\t\t\t    \"data\":{}\n\t\t\t}\n```\n\n**返回结果是json格式的字符串, code: 查询状态，0为成功，data短信信息的json字符串**\n\n## **注意**\n\n> 该方式只能够作用于已开启云开发服务的项目\n\n","tags":["微信小程序"],"categories":["前端"]},{"title":"Node.js-解析请求","url":"/2021/08/07/Node.js-解析请求/","content":"\n## **解析get请求**\n\n**1.引入HTTP模块**\n\n```js\nconst http = require('http')\n```\n\n**2.创建网络服务**\n\n```js\nconst server = http.createServer((req, res) => {\n})\nserver.listen(端口号, \"localhost\")\n```\n\n**3.因为get请求传递的参数位于url中，因此需要先将数据分离出来**\n\n```js\nlet data = req.url.split(\"?\")[1].split(\"&\")\n```\n\n**4.通过for each循环遍历得到的数组，解构数组数据**\n\n```js\nlet dataSet = {}\n        for (let item of data) {\n            let arr = item.split(\"=\")\n            console.log(arr);\n            dataSet[arr[0]] = arr[1]\n        }\n```\n\n**5.通过JSON.stringify()函数将得到的对象字符串化后输出**\n\n​\t**a).设置页面传递的数据**\n\n* 设置请求方式\n* 设置访问地址\n* 设置携带参数\n\n​\t**b).页面输出的结果**\n\n```js\n{\n\tname：'Cappuccino',\n\tage:'20',\n\tsex:'man'\n}\n```\n\n## **解析post请求**\n\n**1.引入HTTP模块**\n\n```js\nconst http = require('http')\n```\n\n**2.创建网络服务**\n\n```js\nconst server = http.createServer((req, res) => {\n})\nserver.listen(端口号, \"localhost\")\n```\n\n**3.因为直接通过req对象是无法取得参数的，所以需要通过设置监听器来获取参数（其中dunk的数据是buffer类型的二进制数据，直接拼接在字符串上可以自动转码为字符串）**\n\n```js\nconsole.log(\"post请求\");\n        let data = \"\"\n        req.addListener(\"data\", dunk => {\n            data += dunk\n        })\n        req.addListener(\"end\", () => {\n            let dataSet = qs.decode(data)\n            res.end(JSON.stringify(dataSet))\n        })\n```\n\n## **querystring字符串处理模块**\n\n**1.querystring.decode()可以自动将字符串的数据转换为JSON对象格式，相当于编码**\n\n**2.querystring.encode()可以将对象重新转换为标准字符串，相当于解码**\n\n**下面附上源码:**\n\n```js\nconst http = require('http')\n    //引入处理字符串的模块\nconst qs = require('querystring')\nconst server = http.createServer((req, res) => {\n    res.writeHead(200, {\n        \"content-Type\": \"text/plain;charset=UTF-8\"\n    })\n    let method = req.method\n    if (method === \"GET\") {\n        //解析get请求\n        console.log(\"get请求\");\n        console.log(req.url);\n        let data = req.url.split(\"?\")[1].split(\"&\")\n        console.log(data);\n        let dataSet = {}\n        for (let item of data) {\n            let arr = item.split(\"=\")\n            console.log(arr);\n            dataSet[arr[0]] = arr[1]\n        }\n        res.end(JSON.stringify(dataSet))\n    } else if (method === \"POST\") {\n        //解析post请求\n        console.log(\"post请求\");\n        let data = \"\"\n        req.addListener(\"data\", dunk => {\n            data += dunk\n        })\n        req.addListener(\"end\", () => {\n            let dataSet = qs.decode(data)\n            res.end(JSON.stringify(dataSet))\n        })\n    }\n\n})\n\nserver.listen(8898, \"localhost\")\n```\n\n","tags":["Node.js"],"categories":["前端"]},{"title":"个人博客搭建","url":"/2021/08/06/个人博客搭建/","content":"\n## 上传本地仓库文件\n\n​\t**从此目录进入 Git Bash，输入 git status 命令查看仓库状态,然后继续本地仓库的上传**\n\n​\t**假设demo已经是一个 Git 仓库了，而我们刚刚创建的文件 demo.txt 没有被追踪，也就是没有提交到本地仓库。现在我们使用 git add 命令将文件添加到了「临时缓冲区」，再用 git commit -m \"提交信息\" 将其提交到本地仓库**\n\n* 如果你是第一次提交的话，就会出现一个情况，会让你输入用户名和邮箱\n\n```c\n#你只要再加两行代码就行：\n$ git config --global user.name\"JustLikeCatnip\"\n$ git config --global user.email\"1741255713@qq.com\"\n```\n\n* 完成后输入 git log 命令查看仓库提交日志：\n\n* 输入 git status 查看一下仓库状态\n\n* 现在输入 git push origin master 命令，将本地仓库提交到远程仓库，origin是远程主机的名字\n\n* 刷新 GitHub 中 text 仓库：\n\n* 这时我们的测试文件已经上传到了 text 仓库中。\n\n### 总结：\n\n**1.克隆仓库**\n\n​\t先到准备好的文件夹内，使用Git Bush\n\n​\tgit clone + (仓库路径)\n\n​\t例如：**git clone https://github.com/JustlikeCatnip/test.git**\n\n**2.本地文件上传**\n\n​\t到克隆好的仓库中，使用Git Bush\n\n​\t先将文件上传到 临时缓冲区\n\n​\t例如：**git add demo.txt**\n\n​\t再将文件上传至本地仓库\n\n​\t例如：**git commit -m “commit demo file”**\n\n**3.将本地仓库提交至远程仓库**\n\n​\t例如：**git push origin master** \n\n## 附言(加入新的主题):\n\n```text\ngit clone https://github.com/Sariay/hexo-theme-Annie.git\n```\n\n**克隆的仓库为你要更换的主题**\n\n``` txt\nHexo主题库：https://hexo.io/themes/\n```\n\n**主题更新**：\n\n**先去到根目录，打开GitBush**\n\n```\nhexo clean   #清除缓存文件 db.json 和已生成的静态文件 public\nhexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)\nhexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)\nhexo s       #开启本地访问端口，默认4000\n```\n\n注意：每当博客内容更新，都需要执行上面三行代码\n\n","tags":["个人博客搭建"],"categories":["个人博客"]},{"title":"《那时》","url":"/2021/08/06/那时/","content":"\n​\t**年关已过，临近开学，像树的层层轮回一样，开始期盼学校里匆忙而又充满希望的日子。**\n\n​\t **回忆上年，也算当了一回努力的人，借着高考留下的余温，做了弥多的努力，也见识了很多从未见过的人和事。** \n\n​\t**许是应了我一个前辈的话，大学更美好，也更像是一个社会。  像是从四面八方涉水而来一般，更多的人像年前的我一样，懵懂而又憧憬这，诗和远方，像是重生，又像是一头栽进另一片萦绕的森林。**\n\n​\t **有坦然者，全身心投入计算机这一伟大事业中去，诚然，也在电脑时间的更替下花费了一根根秀发，培养了自己的理科修为，但扪心自问，仍比不上那些更为专注的同学。  有意无意照了很多回镜子，想通过反射看清自己，同过去，有什么不同，又有什么需要改变，却不知，镜子里的自己，也和自己不是同一个。 渐渐长大，有更多的呼声，让人们趋向于富足满意的生活，但一路走来，偶尔会想到，比起高雅的小夜曲，摇晃的高脚杯，或许幼稚单纯，才是生命中该有的美好。 由衷的讲，物质让人失去平静 ，满足使人满怀信心。** \n\n​\t**前些日子，正视了自己的感情，也向青春做了个告白，美好又短暂，从开始的激动，到忐忑，到不知所踪，最后归于平静。 走出失去，可能还需要时间，不过母庸置疑，每走过的一步步时光，终会在岁月里埋葬这段青涩的回忆，变得不再尴尬，不再不甘，不再语无伦次。**\n\n​\t**回首看来，只觉得美好，只看见自己傻傻地笑着，看着画面里的两个人，有欢声笑语，其中一个不是自己，另一个人也不是她。 这个世界上有很多东西可以通过努力，通过艰苦奋斗得到，但唯独人不行，唯独那个人，唯独她。 不争的事实是，七年前的一天，和前天，感情始终是一样的，不说光阴会改变一个人，你想的和你见到的，可能不是同一个东西，不了解且永不能了解，可那又如何？** \n\n​\t**时间也无法冲淡的东西，足以证明它的珍贵了吧。**\n\n​\t **即便不能继续，那时的我，是真的爱你。 相信一切都是最好的安排，让我们在不同的世界里，各自发光！**","tags":["小记"],"categories":["文章"]},{"title":"《芳夏》","url":"/2021/08/06/芳夏/","content":"\n\n\n**那年初夏，想着摘星。**\n\n**不料，栽进两寸的天堂。**\n\n**即使至于现在，也幻想着未来。**\n\n**有人对我说，只要你是简单的，**\n\n**世界便是简单的。**\n\n**当我跨过鸿沟，步入时间无崖的荒漠里。**\n\n**才明白，简单恰是最复杂的复杂。**\n\n**这是真的，人的一生注定会遇到两个人，**\n\n**一个惊艳了时光，**\n\n**一个温柔了岁月。**\n\n**你，是生命里所能经历的，最切实的存在。**\n\n**你说这不是一场梦。**\n\n**但这一切又像梦一样遥不可及，**\n\n**像梦一样触碰便支离破碎。**\n\n**可我又甘愿生于梦里，**\n\n**那样，**\n\n**能够看见你青涩笑颜，**\n\n**能够在关键时刻对你说不，**\n\n**能够再次静静注视你386秒。**\n\n**当我拾起那朵洁净的玫瑰，**\n\n**手掌的刺痛终于提醒我，**\n\n**这或许不是我的花，**\n\n**只是我恰好经过了你的绽放。**\n\n**到这儿 ，我笑了笑。**\n\n**也许，荒漠也有花海。**\n\n**也许，时间还会回来。**\n\n**也许，梦里也有真物存在。**\n\n**我仍然记得，**\n\n**这生命有个清澈的夏天，**\n\n**在时间的角落里，**\n\n**悄悄绽放，**\n**芳香四溢🌸**","tags":["小记"],"categories":["文章"]},{"title":"《十年以后》","url":"/2021/08/06/十年以后/","content":"\n**我也曾为一句话感动，**\n**也曾哭到泪也干涸。**\n**在最悲伤最无力的那一刻，**\n**我会记得些什么？**\n**是一杯腾腾热气的茶，抑或是会违心说着，**\n**自己一个人也会活的快乐。**\n**会不会记得，那句不敢说出的喜欢呢？**\n**会不会像现在一样任性，**\n**会不会内心一片澄澈，**\n**会不会早已放弃割舍,**\n**我会不会还在这儿，是否仍然一个人追逐着梦想呢？**\n**但愿十年过去，依旧有一个宝贵的人，能在这种时刻，倾听诉说，一遍又一遍的提醒着我。**\n **----原来我，还记得呢！**\n\n","tags":["小记"],"categories":["文章"]},{"title":"Hello World","url":"/2020/10/05/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["Hello"],"categories":["HelloWorld"]}]